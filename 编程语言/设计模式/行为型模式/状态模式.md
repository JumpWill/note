#

## 简介

根据状态的不同而做不同的动作

### 状态模式中的角色和职责

#### 拥有状态者

用有状态的角色

#### 抽象状态

是所有状态类的父类

#### 具体状态

它实现了在抽象状态类中声明的算法，在运行时，具体状态类将覆盖在拥有状态者中定义的抽象状态类对象，使用一种具体的动作实现某个业务处理。

## 代码

商场促销有策略A（0.8折）策略B（消费满200，返现100），用策略模式模拟场景

```golang
package main

import "fmt"


type State interface {
	Do()
}

type Angry struct {}

func (self *Angry) Do()  {
	fmt.Println("Angry")
	
}

type Sad struct {}

func (self *Sad) Do()  {
	fmt.Println("Sad")
	
}

//环境类
type People struct {
    state State
}

func (self *People) SetState(s State) {
	self.state = s
}

func (self *People) Feel() float64 {
	self.state.Do()
}

func main() {
	
    will :=People{}
    will.SetState(Angry{})
    will.Feel()
    will.SetState(Sad{})
    will.Feel()
}
```

## 总结

### 优点

1. 状态模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上根据状态做动作;
2. 使用状态模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种状态的逻辑与状态本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。
3. 状态模式提供了一种算法的复用机制。由于将算法单独提取出来封装在状态类中，因此不同的环境类可以方便地复用这些状态类

### 缺点

1. 客户端必须知道所有的状态，并自行决定使用哪一个状态。
2. 状态模式将造成系统产生很多具体状态类，任何细小的变化都将导致系统要增加一个新的具体状态类

### 适用场景

1. 准备一组算法，并将每一个算法封装起来，使得它们可以互换。

## 状态模式和策略模式的区别与联系

### 区别

1. 状态模式重点在各状态之间的切换，从而做不同的事情；而策略模式更侧重于根据具体情况选择策略，并不涉及切换。
2. 状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如，聚合支付平台，有支付宝. 微信支付. 银联支付，虽然策略不同，但最终做的事情都是支付，也就是说他们之间是可替换的。反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。
3. 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而策略模式通过从Context中分离出策略或算法，我们可以重用它们。
4. 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。
5. 状态模式将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现，当发现传入参数不是自己这个状态所对应的参数，则自己给Context类切换状态；这种转换是"自动"，"无意识"的。状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。而策略模式是直接依赖注入到Context类的参数进行策略选择，不存在切换状态的操作。
6. 策略模式的客户端必须对所有的策略类相当了解，明确当前场景下各种策略的利弊，权衡在当前场景下应该使用哪种策略，也就是是说策略类对客户端是暴露的，策略是外界给的，策略怎么变，是调用者考虑的事情，系统只是根据所给的策略做事情。
状态模式依赖于其状态的变化时其内部的行为发生变化，将动作委托到代表当前状态的对象，对外表现为类发生了变化。状态是系统自身的固有的，由系统本身控制，调用者不能直接指定或改变系统的状态转移。

### 联系

状态模式和策略模式都是为具有多种可能情形设计的模式，把不同的处理情形抽象为一个相同的接口，符合对扩展开放，对修改封闭的原则。
