#

## HTTP1.0

### 特点

无状态无连接的应用层协议

1. 服务器不跟踪不记录请求过的状态
2. 浏览器每次请求都需要建立tcp连接

HTTP/1.0规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）

无状态导致的问题可以借助cookie/session机制来做身份认证和状态记录解决;

### 缺陷

1. 无法复用连接。每次发送请求的时候，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会导致网络的利用率非常低。
2. 队头堵塞(head of line blocking)。由于HTTP/1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求。

## HTTP1.1

### 特点

#### 长连接

HTTP/1.1增加了一个Connection字段，通过设置Keep-alive（默认已设置）可以保持连接不断开，避免了每次客户端与服务器请求都要重复建立释放TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求

#### 支持请求管道化（pipelining）

基于HTTP/1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输,只是将请求一同发出去了,但是后面的请求还是得等到前面的请求完成之后才能完成,逐个响应的送回）

### 缺陷

还是不快

## HTTP2

### 概念

#### 帧

 HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。

#### 流

存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。

#### 消息

与逻辑消息对应的完整的一系列数据帧。

### 特点

#### 二进制分帧

HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

#### 多路复用

* 同域名下的所有通信都在单个连接中完成。
* 单个连接可以承载任意数量的双向数据流。
* 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装
这一特性，使性能有了很大的提升：
* 同个域名只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗。
* 单个连接上可以并行交错地请求和响应，之间互不干扰。
* 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

#### 头部压缩

在HTTP/1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。
比如说cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发送给服务器。（由于cookie比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）
HTTP/2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。

#### 推送

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。
服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

### 总结

HTTP/2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。

### 缺陷

基于TCP,如果在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。
但是对于HTTP/1.1 来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据

## HTTP3

QUIC协议，基于UDP协议
